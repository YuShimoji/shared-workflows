# 設計原則（Design Principles）

プロジェクト横断で守るべき設計原則。チケット起票時・コードレビュー時・Worker実装時に参照する。

---

## 1. データ外部化（Data Externalization）

**原則**: テキスト・設定値・パラメータはコード内にハードコードしない。設定ファイル（JSON/YAML/ScriptableObject等）に外部化する。

**理由**:
- 設定変更がコード変更を伴わない
- 非エンジニアも値を編集できる
- ローカライゼーション・A/Bテスト・バランス調整が容易

**チェックリスト**:
- [ ] 文字列リテラル（UI表示テキスト、メッセージ等）がコード内に埋め込まれていないか
- [ ] 数値パラメータ（速度、ダメージ、タイムアウト等）がマジックナンバーになっていないか
- [ ] 設定値が環境別（dev/staging/prod）に切り替え可能か

### Unity 固有ルール

| データ種別 | 推奨格納先 | 備考 |
|-----------|-----------|------|
| UI表示テキスト | ScriptableObject or Localization Table | ローカライズ対応 |
| ゲームパラメータ | ScriptableObject | Inspector から編集可能 |
| 環境設定 | ScriptableObject or JSON | ビルド設定に応じて切替 |
| アセット参照 | Addressables or ScriptableObject | 直接参照を避ける |

### Web/一般プロジェクト固有ルール

| データ種別 | 推奨格納先 | 備考 |
|-----------|-----------|------|
| UI表示テキスト | i18n JSON / YAML | ローカライズ対応 |
| APIエンドポイント | 環境変数 or .env | ハードコード厳禁 |
| 設定パラメータ | config.json / YAML | 環境別に切替 |
| シークレット | 環境変数 / Secrets Manager | コードに含めない |

---

## 2. 単一責任（Single Responsibility）

**原則**: 1ファイル・1クラス・1関数は1つの責任だけを持つ。

**チェックリスト**:
- [ ] ファイルが複数の無関係な機能を含んでいないか
- [ ] クラスが「データ保持」と「ロジック実行」と「表示」を同時に担っていないか
- [ ] 関数が50行を超えていないか（目安）

---

## 3. 変更容易性（Ease of Change）

**原則**: 設定変更がコード変更を伴わないアーキテクチャを設計する。

**チェックリスト**:
- [ ] 新しいバリエーション追加時にコード変更が不要か（データ追加だけで済むか）
- [ ] 依存関係が一方向か（循環参照がないか）
- [ ] インターフェース/抽象を介して疎結合になっているか

---

## 4. 可視化優先（Visualization First）

**原則**: 構造・依存・データフローは図（Mermaid）で可視化する。テキストだけの説明は避ける。

**適用場面**:
- アーキテクチャ設計時 → `templates/diagrams/architecture.md`
- データフロー設計時 → `templates/diagrams/data-flow.md`
- 変更影響範囲の報告時 → `templates/diagrams/change-map.md`
- タスク進捗の報告時 → `templates/diagrams/task-flow.md`

**ルール**:
- Mermaid を優先（`data/presentation.json` の `diagram.preferred` 準拠）
- ASCII art は原則禁止
- Mermaid非対応環境（Visual Studio等）では Markdown テーブルにフォールバック

---

## 5. テスト駆動（Contract-First Testing）

**原則**: テストは実装の「契約（公開 API の振る舞い）」を検証する。実装の内部詳細をテストしない。

**理由**:
- 内部実装をテストすると、リファクタリングのたびにテストが壊れる（テスト負債の増殖）
- 契約テストは「何をするか」を検証するため、「どうやるか」の変更に耐える
- AIが自律的に品質を検証でき、かつ実装のチューニングを阻害しない

**禁止パターン（Fragile Test Anti-patterns）**:
- private メソッドを直接テストする（リフレクション等で無理やり呼ぶ）
- メソッドの引数の順序・型をテストの前提にする（シグネチャ変更で壊れる）
- 内部状態（private フィールド）をアサートする
- 実装固有のタイミング（フレーム数等）に依存したアサート

**推奨パターン（Contract Test Patterns）**:
- public API を呼び、observable な状態変化・戻り値を検証する
- 「入力 X を与えたとき、結果 Y が観測できる」の形で書く
- boundary value（境界値）と error case（異常系）を優先する

**チェックリスト**:
- [ ] テストは public API のみを呼んでいるか
- [ ] テストが壊れるのは「振る舞いが変わった時」だけか（実装リファクタで壊れないか）
- [ ] Test Phase（Slice / Stable / Hardening）に応じた適切なテスト量か
- [ ] ビルドがエラーなく通過するか

### Unity 固有ルール

| テスト種別 | 対象 | Slice | Stable | Hardening |
|-----------|------|-------|--------|-----------|
| EditMode テスト | 公開 API の契約検証 | 推奨(1-2本) | 必須 | 必須+エッジ |
| PlayMode テスト | ランタイムスモーク | 推奨(1本) | 必須 | 必須+回帰 |
| ビルド検証 | コンパイルエラーゼロ | 必須 | 必須 | 必須 |
| 手動検証 | UI/UX、エディタ拡張 | 必須(基本) | 推奨 | 必須 |

### Web/一般プロジェクト固有ルール

| テスト種別 | 対象 | Slice | Stable | Hardening |
|-----------|------|-------|--------|-----------|
| ユニットテスト | 公開 API の契約検証 | 推奨(1-2本) | 必須 | 必須+エッジ |
| E2E テスト | ユーザーフロー検証 | 不要 | 推奨 | 必須 |
| ビルド検証 | ビルドエラーゼロ | 必須 | 必須 | 必須 |

---

## 6. 学習者への配慮（Learner-Friendly）

**原則**: コード変更時は「どこを変えるとどう動くか」を明示する。

**実践**:
- Worker レポートに `## 変更マップ`（Mermaid graph）を必須で含める
- 重要な変更には `## Before/After` セクションでコード差分の抜粋を添える
- 新パターンを発見した場合は `docs/references/` にサンプルリファレンスとして蓄積する
- `docs/references/PATTERN_*.md` 形式で実装前→実装後の例を記録する

---

## 7. アセンブリ境界の保全（Assembly Boundary Integrity）— Unity 固有

**原則**: Unity の Assembly Definition (asmdef) による型の可視性境界を常に意識し、コンパイルエラーの予防を最優先とする。

**理由**:
- asmdef の参照不足は CS0234/CS0246 を引き起こす
- 同名型の複数アセンブリ定義は CS0029/CS0433 を引き起こす
- interface を Unity generic API に渡すと CS0311 を引き起こす
- これらのエラーは場当たり修正で泥沼化しやすい

**チェックリスト**:
- [ ] 変更対象ファイルが属するアセンブリを特定したか
- [ ] 追加する `using` の型がそのアセンブリの参照先に含まれるか
- [ ] 新規型と同名の型が別アセンブリに存在しないか（`rg "class TypeName"` で確認）
- [ ] asmdef を変更した場合、ASSEMBLY_ARCHITECTURE.md (プロジェクト側) を更新したか
- [ ] 依存方向が DAG (下位→上位のみ) に違反していないか
- [ ] `#if` 条件コンパイルの外にオプショナルシンボルが漏れていないか
- [ ] C# 言語バージョン制約を守っているか

**参照**: プロジェクト側の `docs/02_design/ASSEMBLY_ARCHITECTURE.md` が各プロジェクトのアセンブリ依存グラフの SSOT となる。

---

## 8. エラー修正プロセスの構造化（Structured Error Resolution）

**原則**: コンパイルエラーを「場当たり修正」せず、診断→原因特定→修正→検証の手順に従う。

**理由**:
- 場当たり修正は新たなエラーを生み、修正ループが泥沼化する
- 原因を理解せずに修正すると、同種のエラーが繰り返し発生する

**手順**:
1. エラーコードで分類する（型未解決 / 型重複 / generic 制約 / 言語バージョン / シンボル未定義）
2. 各分類に対応した診断フローに従い、根本原因を特定する
3. 原因に対する最小修正を適用する
4. 全エラーが消えたことを確認してから次の作業に移る

**参照**: プロジェクト側の `docs/03_guides/COMPILATION_GUARD_PROTOCOL.md` に診断フローの詳細がある。

---

## 9. ドキュメント散逸の防止（Documentation Discipline）

**原則**: 情報の SSOT を 1 箇所に定め、他からはリンクする。同じ情報を複数箇所に書かない。

**チェックリスト**:
- [ ] 新しいドキュメントを作る前に、既存ドキュメントで対応できないか確認したか
- [ ] 作成するドキュメントの配置先は `docs/` 配下の適切なサブディレクトリか
- [ ] SSOT が明確に定義されているか（どのファイルが正なのか）
- [ ] 古くなった情報を含むドキュメントを更新 or アーカイブしたか

**ドキュメント配置規約** (Unity プロジェクト):

| 種別 | 配置先 | SSOT |
|------|--------|------|
| アーキテクチャ設計 | `docs/02_design/` | 各ファイルが該当分野の SSOT |
| 開発ガイド・手順 | `docs/03_guides/` | -- |
| 計画・ロードマップ | `docs/01_planning/` | DEVELOPMENT_ROADMAP が計画の SSOT |
| 作業レポート | `docs/04_reports/` | -- |
| タスクチケット | `docs/tasks/` | -- |
| 変更提案 | `openspec/changes/{name}/` | -- |
| プロジェクト全体 | `docs/SSOT_WORLD.md` | 最上位 SSOT |
