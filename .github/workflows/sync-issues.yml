name: Reusable Sync Issues from docs

on:
  workflow_call:
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - docs/ISSUES.md

permissions:
  issues: write
  contents: read

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout caller repo
        uses: actions/checkout@v4

      - name: Create or update issues from docs/ISSUES.md
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            function parseIssuesFromMarkdown(filePath){
              const text = fs.readFileSync(filePath, 'utf-8');
              const lines = text.split(/\r?\n/);
              const sections = [];
              let cur = null;
              for (const line of lines){
                const m = /^##\s+(.+)$/.exec(line.trim());
                if (m){
                  if (cur) sections.push(cur);
                  cur = { heading: m[1].trim(), body: [] };
                } else if (cur){
                  cur.body.push(line);
                }
              }
              if (cur) sections.push(cur);
              const items = [];
              for (const s of sections){
                const title = s.heading.replace(/^\d+\)\s*/, '').trim();
                const body = s.body.join('\n').trim();
                if (!title) continue;
                items.push({
                  title,
                  body,
                  labels: ['product:backlog','type:enhancement','managed:docs-sync']
                });
              }
              return items;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const wanted = parseIssuesFromMarkdown(path.join(process.cwd(), 'docs', 'ISSUES.md'));
            const wantedByTitle = new Map(wanted.map(i => [i.title, i]));

            const { data: existingAll } = await github.rest.issues.listForRepo({ owner, repo, state: 'all', per_page: 100 });

            for (const item of wanted){
              const found = existingAll.find(i => i.title === item.title);
              if (found){
                try {
                  const newLabels = Array.from(new Set([...(found.labels||[]).map(l=> typeof l === 'string' ? l : l.name), ...item.labels]));
                  await github.rest.issues.update({ owner, repo, issue_number: found.number, body: item.body, labels: newLabels, state: 'open' });
                  core.info(`Updated: ${item.title} (#${found.number})`);
                } catch (e) {
                  core.warning(`Update with labels failed for ${item.title}: ${e.message}. Retrying without labels...`);
                  await github.rest.issues.update({ owner, repo, issue_number: found.number, body: item.body, state: 'open' });
                  core.info(`Updated (no labels): ${item.title} (#${found.number})`);
                }
              } else {
                try {
                  const res = await github.rest.issues.create({ owner, repo, title: item.title, body: item.body, labels: item.labels });
                  core.info(`Created: ${item.title} (#${res.data.number})`);
                } catch (e) {
                  core.warning(`Create with labels failed for ${item.title}: ${e.message}. Retrying without labels...`);
                  const res2 = await github.rest.issues.create({ owner, repo, title: item.title, body: item.body });
                  core.info(`Created (no labels): ${item.title} (#${res2.data.number})`);
                }
              }
            }

            for (const ex of existingAll){
              const hasManaged = (ex.labels||[]).some(l => (typeof l === 'string' ? l : l.name) === 'managed:docs-sync');
              if (hasManaged && !wantedByTitle.has(ex.title) && ex.state === 'open'){
                await github.rest.issues.update({ owner, repo, issue_number: ex.number, state: 'closed' });
                core.info(`Closed removed issue: ${ex.title} (#${ex.number})`);
              }
            }
